#! usr/bin/env python
# mutantanalysis.py

"""From a list of variants in multiple genomes, classify each variant
as a nonsynonymous coding region, synonymous coding region, terminator
region, promoter region, or "other". If a file includes a segregant pool,
rank each mutation by its segregation frequency. Output in html format
with links to read data and alignments.

Please see the README file on my github site for more documentation.
https://github.com/koschwanez/mutantanalysis

"""

import os
import os.path
import shutil
import subprocess
import sys
import argparse
import datetime
from collections import defaultdict
from operator import attrgetter
from string import Template

from Bio import SeqIO
from Bio.SeqFeature import SeqFeature, FeatureLocation
from Bio.SeqRecord import SeqRecord
from Bio.Align.Applications import ClustalwCommandline
from Bio import AlignIO
import pysam

__author__ = "John Koschwanez"
__copyright__ = "Copyright 2012"
__credits__ = ["John Koschwanez"]
__license__ = "GPL"
__version__ = "3.0"
__maintainer__ = "John Koschwanez"
__email__ = "john.koschwanez@gmail.com"
__status__ = "Production"

CURDIR = os.path.abspath(os.path.dirname(sys.argv[0]))

TEMPLATES = dict(
    main=os.path.join(CURDIR, 'seq_template.html'),
    gene=os.path.join(CURDIR, 'seq_gene_template.html'),
    strain=os.path.join(CURDIR, 'seq_strain_template.html'),
    reads=os.path.join(CURDIR, 'seq_read_align_template.html'),
    mutation=os.path.join(CURDIR, 'seq_mutation_template.html')
)
CSS_FILE = os.path.join(CURDIR, 'mutantanalysis.css')
BASE_CSS_FILE = os.path.join(CURDIR, 'reset-fonts-grids.css')  # Yahoo API. May need to update.
TABBED_OUTPUT = os.path.join(CURDIR, 'tabbed_output.txt')
MUTATION_OUTPUT = os.path.join(CURDIR, 'mutation_output.txt')
try:
    CLUSTAL_BINARY = subprocess.check_output(["which","clustalw"]).strip()
except:
    try:
        clustal_pwd = os.path.join(CURDIR, "clustalw")
        CLUSTAL_BINARY = subprocess.check_output(
                ["which","clustal_pwd"]).strip()
    except:
        print("clustalw must be in environmental path or in working directory")
        quit()


def segregant_analysis_with_clone(
    title, ancestor_name, ancestor_bam_filename,
    genome_fasta, chr_name_filename, features_filename, output_directory,
    clone_name, clone_bam_filename,
    ancestor_to_clone_snp_filename, ancestor_to_clone_indel_filename,
    read_percent_to_call_mutation,
    pool_name, pool_bam_filename, pool_snp_filename, pool_indel_filename,
    read_percent_to_call_segregating
):
    """Perform segregant analysis.

    Perform segregant analysis from an ancestor, clone, and segregant pool.
    Args:
        title: String (e.g. Evolved clone 1) used to label analysis.
        ancestor_name: String with name of ancestor strain
        ancestor_bam_filename: Ancestor reads in sorted bam format
        genome_fasta: fasta file containing genome
            MUST match genome used for upstream analysis
        chr_name_filename: tab-delimited file used if fasta id is different
            from the chromosome name or number to be used in the output
            chromosome_name_to_be_used, chromosome_id_in_fasta_file
        features_filename: reference genome tab-delimited file as follows:
            chromosome, min_position, max_position, type, gene_name,
            feature_name, strand, SGDID, SGDID_pt, parent_feature_name
        output_directory: all files outputted here
        clone_name: String with name of clone strain
        clone_bam_filename: Clone reads in sorted bam format
        ancestor_to_clone_snp_filename: snp generated by Varscan using
            somatic command to compare ancestor and clone.
            TODO: use VCF format
        ancestor_to_clone_indel_filename: snp generated by Varscan using
            somatic command to compare ancestor and clone.
            TODO: use VCF format
        read_percent_to_call_mutation: 1-100
            Best to use > 60%
        pool_name: String with name of segregant pool
        pool_bam_filename: Pool reads in sorted bam format
        pool_snp_filename: generated by Varscan using pileup2snp command.
            TODO: use VCF format
        pool_indel_filename: generated by Varscan using pileup2indel command.
            TODO: use VCF format
        read_percent_to_call_segregating: 1-100
            Important to set high so that alignment of genes only includes
            those mutations that segregate.

    Returns:
        Outputs html file with mutations in order of segregation
        and links to reads, DNA alignments, protein alignments.

    """
    analysis = AnalysisPipeline(
        title, ancestor_name, ancestor_bam_filename,
        genome_fasta, chr_name_filename, features_filename,
        output_directory)
    analysis.one_clone_one_pool(
        clone_name, clone_bam_filename, read_percent_to_call_mutation,
        ancestor_to_clone_snp_filename, ancestor_to_clone_indel_filename,
        pool_name, pool_bam_filename, pool_snp_filename, pool_indel_filename,
        read_percent_to_call_segregating)


def compare_multiple_clones(
    title, ancestor_name, ancestor_bam_filename,
    genome_fasta, chr_name_filename, features_filename,
    output_directory, list_of_multiple_clone_tuples,
    include_ref_differences
):
    """Compare clones without segregation.

    Variants from multiple clones are compared. Still requires one
    strain to be labeled as the ancestor.
    Args:
        title: String (e.g. Evolved clone 1) used to label analysis.
        ancestor_name: String with name of ancestor strain
        ancestor_bam_filename: Ancestor reads in sorted bam format
        genome_fasta: fasta file containing genome
            MUST match genome used for upstream analysis
        chr_name_filename: tab-delimited file used if fasta id is different
            from the chromosome name or number to be used in the output
            chromosome_name_to_be_used, chromosome_id_in_fasta_file
        features_filename: reference genome tab-delimited file as follows:
            chromosome, min_position, max_position, type, gene_name,
            feature_name, strand, SGDID, SGDID_pt, parent_feature_name
        output_directory: all files outputted here
        list_of_multiple_clone_tuples: tuple with following info:
            clone_name: String with name of clone strain
            clone_bam_filename: Clone reads in sorted bam format
            ancestor_to_clone_snp_filename: snp generated by Varscan using
                somatic command to compare ancestor and clone.
                TODO: use VCF format
            ancestor_to_clone_indel_filename: snp generated by Varscan using
                somatic command to compare ancestor and clone.
                TODO: use VCF format
            read_percent_to_call_mutation: 1-100
                Best to use > 60%
        include_ref_differences: use only if all mutations from
            reference are to be included.
    Returns:
        Outputs html file with mutations in order of segregation
        and links to reads, DNA alignments, protein alignments.

    """
    analysis = AnalysisPipeline(
        title, ancestor_name, ancestor_bam_filename,
        genome_fasta, chr_name_filename, features_filename, output_directory)
    analysis.compare_multiple_clones(
        list_of_multiple_clone_tuples, include_ref_differences)


class AnalysisPipeline(object):
    """Controlling class containing analysis pipeline.

    A single instance of this class is generated
    by one of the globally accessed functions. The instance is first
    created and then one of the pipeline functions are called.

    """
    def __init__(
            self, title, ancestor_name, ancestor_bam_filename,
            genome_fasta, chr_name_filename, features_filename,
            output_directory):
        self.title = title
        self.output_directory = output_directory
        self.clustal_binary = CLUSTAL_BINARY
        self.genome = Genome(genome_fasta, chr_name_filename, features_filename)
        self.ancestor = Ancestor(
            ancestor_name, ancestor_bam_filename, self.genome)
        self.data_output = DataOutput(self.genome, self)
        self.mutation_dict = defaultdict(list)
        self.gene_dict = {}
        self.list_of_mutation_positions_with_no_gene = []
        self.read_percent_to_call_segregating = 0.0  # default value
        self.clone_list = []
        self.clone_ancestor_list = []

    def one_clone_one_pool(
            self, clone_name, clone_bam_filename,
            read_percent_to_call_mutation,
            ancestor_to_clone_snp_filename,
            ancestor_to_clone_indel_filename,
            pool_name, pool_bam_filename,
            pool_snp_filename, pool_indel_filename,
            read_percent_to_call_segregating):
        """Called by global function segregant_analysis_with_clone()"""
        self.include_reference_differences = False  # Ignore ref strain diffs
        self.include_seg_data = True
        self.read_percent_to_call_segregating = read_percent_to_call_segregating
        self.clone = Clone(
            clone_name, clone_bam_filename,
            ancestor_to_clone_snp_filename, ancestor_to_clone_indel_filename,
            self.ancestor, read_percent_to_call_mutation, self.genome)
        self.pool = Pool(
            pool_name, pool_bam_filename,
            pool_snp_filename, pool_indel_filename, self.clone, self.genome)
        self.clone_list = [self.clone]
        self.clone_ancestor_list = [self.clone, self.ancestor]
        self.clone_ancestor_pool_list = [self.clone, self.ancestor, self.pool]
        self.clone.add_mutations(self.mutation_dict)
        self.pool.add_segregation_data(self.mutation_dict)
        self.generate_gene_dict_from_mutation_dict()
        self.generate_sorted_gene_list()
        self.generate_gene_data()
        self.data_output.generate_segregation_output()

    def compare_multiple_clones(
            self, list_of_multiple_clone_tuples, include_ref_differences):
        """Called by global function compare_multiple_clones()"""
        self.include_reference_differences = include_ref_differences
        self.include_seg_data = False
        for (clone_name, clone_bam_filename,
                ancestor_to_clone_snp_filename,
                ancestor_to_clone_indel_filename,
                read_percent_to_call_mutation) in list_of_multiple_clone_tuples:
            self.clone_list.append(
                Clone(
                    clone_name, clone_bam_filename,
                    ancestor_to_clone_snp_filename,
                    ancestor_to_clone_indel_filename, self.ancestor,
                    read_percent_to_call_mutation, self.genome))
        self.clone_ancestor_list = list(self.clone_list)
        self.clone_ancestor_list.append(self.ancestor)
        self.clone_ancestor_pool_list = self.clone_ancestor_list

        for clone in self.clone_list:
            print("now adding mutations for clone " + clone.name)
            clone.add_mutations(self.mutation_dict)
        print("now generating gene dictionary")
        self.generate_gene_dict_from_mutation_dict()
        print("now generating gene data")
        self.generate_sorted_gene_list()
        self.generate_gene_data()
        print("now generating output")
        self.data_output.generate_multiple_clone_output(
            self.include_reference_differences)

    def generate_gene_dict_from_mutation_dict(self):
        """Generate the gene dictionary from the mutation dictionary.

        The mutation dictionary is a list of mutation keyed by the
        chromosome number and position. The mutation list has one entry
        for each sample. There could be multiple genes (sgdid_pt) for
        each mutation (e.g. promoter of one gene and ORF of the other).
        The gene dictionary contains an instance of a Gene keyed
        by the sgdid. If there already is a gene in the dictionary,
        then another mutation is added to the Gene instance.

        """
        for mutation_list in self.mutation_dict.values():
            for mutation in mutation_list:
                for sgdid_pt in mutation.sgdid_pt_list:
                    #same mutation could be in different sgdid_pt
                    if sgdid_pt not in self.gene_dict:
                        #could have two mutations in same gene
                        self.gene_dict[sgdid_pt] = Gene(
                            sgdid_pt, self, self.genome)
                    self.gene_dict[sgdid_pt].add_mutation(mutation)
                    mutation.gene_list.append(self.gene_dict[sgdid_pt])
                if not mutation.sgdid_pt_list:
                    mutation.sgdid_pt_list.append('No sgdid')
                    self.list_of_mutation_positions_with_no_gene.append((
                        mutation.chr_num, mutation.position))
                    break

    def generate_sorted_gene_list(self):
        """Filters and sorts genes on mutation and segregation.

        The genes are first run through two filters.
        1. Is the clone mutated from the ancestor? If reference
        differences are not to be included, these genes are removed.
        2. Does the gene segregate? If segregation data is
        included, the genes are sorted by segregant fraction.

        """
        for gene in self.gene_dict.values():
            gene.determine_if_clone_mutated_from_ancestor()
            if self.include_seg_data:
                gene.determine_if_gene_segregates()
        if not self.include_reference_differences:
            self.gene_list = [
                gene for gene in self.gene_dict.values()
                if gene.clone_mutated_from_ancestor]
        else:
            self.gene_list = self.gene_dict.values()
        if self.include_seg_data:
            self.gene_list = sorted(
                self.gene_list,
                key=attrgetter('gene_max_segregating_percent'),
                reverse=True)

    def generate_gene_data(self):
        """Call each gene to generate sequences and alignment outputs."""
        for gene in self.gene_list:
            gene.generate_data(
                self.include_seg_data, self.include_reference_differences)


class Sample(object):
    """Superclass for each sample

    Each sample requires a sorted bam and the name of the parent sample.
    The index to the genome is also passed.

    """
    def __init__(self, name, bam_filename, parent, genome):
        self.name = name
        print(self.__class__.__name__, self.name)
        self.bam_filename = bam_filename
        self.parent = parent
        self.genome = genome

    def return_parent_name(self):
        """Return parent name; called by strain summary in html output."""
        if self.parent:
            return(self.parent.name)
        else:
            return("None")


class Ancestor(Sample):
    """Ancestor sample.

    Ancestor sample does not require a parent or mutation info."""

    def __init__(self, name, bam_filename, genome):
        Sample.__init__(self, name, bam_filename, None, genome)


class Clone(Sample):
    """Clone sample.

    The clone sample requires ancestor name and variants between
    it and the ancestor."""

    def __init__(
            self, name, bam_filename, mutation_snp_filename,
            mutation_indel_filename, ancestor,
            read_percent_to_call_mutation, genome):
        Sample.__init__(self, name, bam_filename, ancestor, genome)
        self.mutation_snp_filename = mutation_snp_filename
        self.mutation_indel_filename = mutation_indel_filename
        self.read_percent_to_call_mutation = read_percent_to_call_mutation

    def add_mutations(self, mutation_dict):
        """Separately parse snp and indel files."""
        self.parse_varscan_mutation_file(
            mutation_dict, 'snp', self.mutation_snp_filename)
        self.parse_varscan_mutation_file(
            mutation_dict, 'indel', self.mutation_indel_filename)

    def parse_varscan_mutation_file(
            self, mutation_dict, snp_or_indel, filename):
        """Parse 'somatic' file output from Varscan.

        Varscan is meant for calling cancer mutations, but it is used here
        to differentiate differences from the reference as follows:
            if ancestor and clone differ from ref: Germline
                Labeled here as 'shares ancestor mutation'
            if clone only differs from ref: Somatic
                Labeled here as 'forward mutation'
            if ancestor only differs from ref: Unknown OR LOH
                Labeled here as backmutation
        Each mutation is then added to the mutation_dict dictionary as
        an instance of the class Mutation.
        Important! Note that the key for the mutation_dict is the
        chr_num and position - this ensures that mutations from multiple
        samples are collected.

        """
        min_percent_for_mutation = 1.0 * self.read_percent_to_call_mutation
        max_percent_for_ref = 100.0 - min_percent_for_mutation

        for line in open(filename):
            split_line = line.split('\t')
            if (split_line[0].endswith("hrom")):
                continue  # first line, ignore
            chr_num = self.genome.chromID_to_chr_num_lookup_dict[split_line[0]]
            position = int(split_line[1]) - 1  # python numbering
            varscan_mutation_type = split_line[12]
            ancestor_variant_percent = float(split_line[6].rstrip('%'))
            clone_variant_percent = float(split_line[10].rstrip('%'))
            if (varscan_mutation_type == "Germline" and
                    ancestor_variant_percent > min_percent_for_mutation and
                    clone_variant_percent > min_percent_for_mutation):
                mutation_type = 'shares ancestor mutation'
            elif ((varscan_mutation_type == "Unknown" or
                    varscan_mutation_type == "LOH") and
                    ancestor_variant_percent > min_percent_for_mutation and
                    clone_variant_percent < max_percent_for_ref):
                mutation_type = 'backmutation'
            elif (varscan_mutation_type == "Somatic" and
                    ancestor_variant_percent < max_percent_for_ref and
                    clone_variant_percent > min_percent_for_mutation):
                mutation_type = 'forward mutation'
            else:
                continue
            mutation_dict[(chr_num, position)].append(Mutation(
                self.genome, self, chr_num, position, snp_or_indel,
                split_line[2], split_line[3], split_line[4], split_line[5],
                split_line[8], split_line[9], mutation_type))


class Pool(Sample):
    """The segregant pool sample.

    The segregant pool sample requires a clone parent, if available,
    and a list of variants from the reference genome."""

    def __init__(
            self, name, bam_filename, pool_snp_filename,
            pool_indel_filename, clone, genome):
        Sample.__init__(self, name, bam_filename, clone, genome)
        self.pool_snp_filename = pool_snp_filename
        self.pool_indel_filename = pool_indel_filename
        self.mismatch_list = []

    def add_segregation_data(self, mutation_dict):
        """Separately parse snp and indel files."""
        self.parse_varscan_pool_file(
            'snp', self.pool_snp_filename, mutation_dict)
        self.parse_varscan_pool_file(
            'indel', self.pool_indel_filename, mutation_dict)

    def parse_varscan_pool_file(self, snp_or_indel, filename, mutation_dict):
        """Parse variant output from Varscan.

        Only variants from reference are included in the Varscan file.
        Each of these variants are checked for in the parent's mutation
        dictionary. If the mutations exist, the segregation info is added
        to the mutation. The mutation_dict of the parent should be passed.

        """
        for line in open(filename):
            split_line = line.split('\t')
            if (split_line[0].endswith("hrom")):
                continue  # first line, ignore
            chr_num = self.genome.chromID_to_chr_num_lookup_dict[split_line[0]]
            position = int(split_line[1]) - 1  # python numbering
            if (chr_num, position) in mutation_dict:
                for mutation in mutation_dict[chr_num, position]:
                    if mutation.sample.name == self.parent.name:
                        mutation.add_segregation_info(
                            self, split_line, snp_or_indel, 'varscan')


class Mutation(object):
    """A single mutation in a sample.

    One mutation corresponds to one base in one sample. Called by
    Clone class. The Analysis instance will maintain the mutation_dict
    dictionary that lists the mutation for each sample. The gene_list
    will be populated by the generate_gene_dict_from_mutation_dict
    in the Analysis instance.

    """
    def __init__(
            self, genome, sample, chr_num, position, snp_or_indel,
            ref_base, variant_base,
            num_ref_reads_ancestor, num_variant_reads_ancestor,
            num_ref_reads_clone, num_variant_reads_clone, mutation_type):
        self.genome = genome
        self.sample = sample
        self.chr_num = chr_num
        self.position = position
        self.snp_or_indel = snp_or_indel
        self.ref_base = ref_base
        self.variant_base = variant_base
        self.num_ref_reads_ancestor = int(num_ref_reads_ancestor)
        self.num_variant_reads_ancestor = int(num_variant_reads_ancestor)
        self.num_ref_reads_clone = int(num_ref_reads_clone)
        self.num_variant_reads_clone = int(num_variant_reads_clone)
        self.mutation_type = mutation_type
        self.reads_total_ancestor = (
            self.num_ref_reads_ancestor + self.num_variant_reads_ancestor)
        self.reads_total_clone = int(
            self.num_ref_reads_clone + self.num_variant_reads_clone)
        self.percent_variant_reads_clone = round(
            100.0 * float(self.num_variant_reads_clone) /
            float(self.reads_total_clone))
        self.segregation_info_list = []
        self.mutation_max_segregating_percent = 0.0
        self.mutation_segregates = False
        self.sgdid_pt_list = self.lookup_position_return_sgdid_pt_list()
        self.gene_list = []

    def add_segregation_info(
            self, sample_pool, list_of_values, snp_or_indel, caller_to_parse):
        """Called by Pool instance to add segregation info."""
        self.segregation_info_list.append(SegregationInfo(
            sample_pool, list_of_values, snp_or_indel, caller_to_parse))

    def generate_output_for_mutation_tabbed_output(self):
        """Return one line for tabbed output describing mutation."""
        if (self.mutation_type == 'forward mutation' or
                self.mutation_type == 'backmutation'):
            gene_list_str = \
                ','.join([gene.gene_name for gene in self.gene_list])
            mut_template = '%(chr)d\t%(pos)d\t%(snp)s\t%(seg)d\t%(gen)s\n'
            mut_inserts = {
                'chr': self.chr_num,
                'pos': self.position,
                'snp': self.snp_or_indel,
                'seg': self.mutation_max_segregating_percent,
                'gen': gene_list_str
            }
            return(mut_template % mut_inserts)

    def lookup_position_return_sgdid_pt_list(self):
        """Return sgdid_pt for the mutation; could be more than one."""
        sgdid_pt_list = []
        for feature in self.genome.chromosome[self.chr_num].record.features:
            if self.position in feature:
                sgdid_pt_list.append(feature.qualifiers['SGDID_pt'])
        return(sgdid_pt_list)

    def determine_if_mutation_segregates(self, min_percent_to_call_segregant):
        """Find segregating percentage for mutation and compare to setpoint.

        Called by position summary containing the mutation.

        """
        if self.mutation_type == 'shares ancestor mutation':
            return  # Don't count changes in this case
        mutation_max_seg_percent = 0.0
        for segregating_info in self.segregation_info_list:
            mutation_max_seg_percent = max(
                mutation_max_seg_percent, segregating_info.seg_percent)
        self.mutation_max_segregating_percent = mutation_max_seg_percent
        if mutation_max_seg_percent > min_percent_to_call_segregant:
            self.mutation_segregates = True

    def __eq__(self, other):
        """Unused. Kept from old version because it may be useful."""
        return (self.chr_num == other.chr_num
                and self.position == other.position
                and self.snp_or_indel == other.snp_or_indel
                and self.read_base == other.read_base)

    def __ne__(self, other):
        """Unused. Kept from old version because it may be useful."""
        return(
            self.chr_num != other.chr_num
            or self.position != other.position
            or self.snp_or_indel != other.snp_or_indel
            or self.read_base != other.read_base)


class SegregationInfo(object):
    """Segregation data corresponding to a mutation.

    Initialized by add_segregation_info in Mutation class. Data comes
    from segregating pool variant file.

    """
    def __init__(self, sample, list_of_values, snp_or_indel, caller_to_parse):
        self.pool_name = sample.name
        self.snp_or_indel = snp_or_indel
        if caller_to_parse == "varscan":
            self.seg_base = list_of_values[-1]
            self.tot_reads = int(list_of_values[4]) + int(list_of_values[5])
            self.seg_percent = (
                100.0 * float(list_of_values[5]) / self.tot_reads)


class Genome(object):
    """Reference genome.

    This single-instance class is called for each gene lookup. Note that
    the name of the chromosome in the fasta file must match the name of
    the chromosome in the variant files and the bam files.

    args:
        genome_fasta: all chromosomes in one fasta file
        chr_name_filename: optional file to change chromosome names
            especially useful for nonsensical SGD names
        features_filename: generated from separate script
            TODO: move script into this package

    """
    def __init__(self, genome_fasta, chr_name_filename, features_filename):
        chrom_id_to_name_lookup = {}
        self.chromosome = {}
        if chr_name_filename:  # optional input; None otherwise
            for line in open(chr_name_filename, 'r'):
                split_line = line.strip().split('\t')
                chrom_num = split_line[0]
                if self.is_number(chrom_num):
                    chrom_num = int(chrom_num)
                chrom_id = split_line[1]
                chrom_id_to_name_lookup[chrom_id] = chrom_num
        for record in SeqIO.parse(genome_fasta, "fasta"):
            if record.id in chrom_id_to_name_lookup:
                chrom_num = chrom_id_to_name_lookup[record.id]
            else:
                chrom_num = chrom_id
            self.chromosome[chrom_num] = \
                Chromosome(chrom_num, record)

        self.chromID_to_chr_num_lookup_dict = (
            self.make_chromID_to_chr_num_lookup())
        self.chr_num_to_chromID_lookup_dict = (
            self.make_chr_num_to_chromID_lookup())
        for line in open(features_filename, 'r'):
            single_feature = line.split('\t')
            chromosome_number = single_feature[0]
            if chromosome_number == '2-micron':
                continue
            self.chromosome[int(chromosome_number)].add_feature(single_feature)
        for chrom in self.chromosome.values():
            chrom.parse_introns()
        self.SGDID_pt_to_feature_lookup = \
            self.make_SGDID_pt_to_feature_lookup()

    def is_number(self, s):
        """Return True if input can be converted to float."""
        try:
            float(s)
            return True
        except ValueError:
            return False

    def make_chromID_to_chr_num_lookup(self):
        """Make dict for chromosome ID to chromosome number"""
        chromID_to_chr_num_lookup_dict = {}
        for chr_num, seqrec in self.chromosome.iteritems():
            chromID_to_chr_num_lookup_dict[seqrec.record.id] = chr_num
        return(chromID_to_chr_num_lookup_dict)

    def make_chr_num_to_chromID_lookup(self):
        """Make dict for chromosome number to chromosome ID"""
        chr_num_to_chromID_lookup_dict = {}
        for chr_num, seqrec in self.chromosome.iteritems():
            chr_num_to_chromID_lookup_dict[chr_num] = seqrec.record.id
        return(chr_num_to_chromID_lookup_dict)

    def make_SGDID_pt_to_feature_lookup(self):
        """Make dict for SGDID_pt to feature"""
        SGDID_pt_to_feature_lookup = {}
        for chr_num, seqrec in self.chromosome.iteritems():
            for feature in self.chromosome[chr_num].record.features:
                SGDID_pt_to_feature_lookup[
                    feature.qualifiers['SGDID_pt']] = (chr_num, feature)
        return(SGDID_pt_to_feature_lookup)


class Chromosome(object):
    """Chromosome sequence and gene info.

    Indexes chromosome, including introns, for lookup. Initiated
    by genome class.

    """
    def __init__(self, number, seq_record):
        self.number = number
        self.record = seq_record

    def add_feature(self, single_feature):
        """Add feature (gene, promoter, terminator, etc.) to chromosome."""
        start_loc = int(single_feature[1]) - 1  # Python numbering
        end_loc = int(single_feature[2])  # Python numbering
        if single_feature[6] == 'W':
            strand = 1
        elif single_feature[6] == 'C':
            strand = -1
        else:
            strand = 0

        self.record.features.append(SeqFeature(
            FeatureLocation(start_loc, end_loc),
            type=single_feature[3],
            strand=strand,
            qualifiers={
                'SGDID': single_feature[7],
                'SGDID_pt': single_feature[8],
                'feature_name': single_feature[5],
                'parent_feature_name': single_feature[9].rstrip('\n'),
                'gene_name': single_feature[4],
            }
        ))

    def parse_introns(self):
        """Parse genes with introns. TODO: Much more testing."""
        intron_features = [
            feature for feature in self.record.features
            if feature.type == 'intron']
        for intron in intron_features:
            intron_start_loc = int(str(intron.location.start))
            intron_end_loc = int(str(intron.location.end))
            parent_features = [
                parent_feature for parent_feature
                in self.record.features
                if (intron_start_loc in parent_feature
                    and parent_feature.type != 'intron'
                    and parent_feature.qualifiers['feature_name'] ==
                    intron.qualifiers['parent_feature_name'])]
            for parent in parent_features:
                parent.location_operator = 'join'
                parent_start_loc = int(str(parent.location.start))
                parent_end_loc = int(str(parent.location.end))
                old_exon_locations = []
                #First start anew with exon locations
                if not parent.sub_features:
                    old_exon_locations.append((
                        parent_start_loc, parent_end_loc))
                if parent.sub_features:
                    for sub_feature in parent.sub_features:
                        old_exon_locations.append(
                            (int(str(sub_feature.location.start)),
                                int(str(sub_feature.location.end)))
                        )
                    parent.sub_features = []

                #Now find the exon that need to be split and generate
                #revised list
                revised_exon_locations = []
                for old_location in old_exon_locations:
                    old_exon_start = old_location[0]
                    old_exon_end = old_location[1]
                    if (intron_start_loc > old_exon_start
                            and intron_end_loc < old_exon_end):
                        revised_exon_locations.append(
                            (old_exon_start, intron_start_loc))
                        revised_exon_locations.append(
                            (intron_end_loc, old_exon_end))
                    else:
                        revised_exon_locations.append(
                            (old_exon_start, old_exon_end))

                for revised_location in revised_exon_locations:
                    revised_start = revised_location[0]
                    revised_end = revised_location[1]
                    parent.sub_features.append(SeqFeature(
                        FeatureLocation(
                            revised_start, revised_end),
                        strand=parent.strand))


class Gene(object):
    """Gene class for collection of mutation info.

    One instance of class Gene is generated for each sgdid_pt
    (which is the sgdid with promoter and terminator suffixes) in the
    mutation dictionary. The instance is first created by
    generate_gene_dict_from_mutation_dict if it does not
    exist in the gene_dict. Then mutations are added from the same
    function with the add_mismatch function (for >1 mutation/gene).
    Overall mutation info for the gene is kept here, but info
    about each mismatched location is contained in an instance
    of the PositionSummary class, collected in the
    position_summary_dict and referenced by the position
    on the chromosome."""

    def __init__(self, sgdid_pt, analysis, genome):
        self.sgdid_pt = sgdid_pt
        self.analysis = analysis
        self.genome = genome
        self.clone_mutated_from_ancestor = False  # default value

        self.chr_num, self.feature = (
            self.genome.SGDID_pt_to_feature_lookup[sgdid_pt])
        self.type = self.feature.type
        self.gene_name = self.feature.qualifiers['gene_name']
        self.sgdid = self.feature.qualifiers['SGDID']
        if self.gene_name:
            self.univ_gene_name = self.gene_name
        else:
            self.univ_gene_name = self.sgdid
        self.feature_name = self.feature.qualifiers['feature_name']

        self.clone_names = [
            sample.name for sample in self.analysis.clone_list]
        self.ancestor_name = self.analysis.ancestor.name
        self.clone_ancestor_names = [
            sample.name for sample in self.analysis.clone_ancestor_list]
        self.position_summary_dict = {}

        self.gene_max_segregating_percent = 0.0
        self.dna_sequences = {}
        self.protein_sequences = {}

        self.is_nonsynonymous = False
        self.gene_segregates = False

        if self.gene_name == "BUD4":
            self.print_debug = True
        else:
            self.print_debug = False

    def add_mutation(self, mutation):
        """Add mutation to gene. Can be more than one position."""
        if mutation.position in self.position_summary_dict:
            self.position_summary_dict[mutation.position].add_mutation(
                mutation)
        else:
            self.position_summary_dict[mutation.position] = \
                PositionSummary(mutation, self.genome, self)

    def determine_if_clone_mutated_from_ancestor(self):
        """Check positions, return True if clone and ancestor genes differ."""
        if self.print_debug:
            print("now checking gene for mutation from ancestor")
        for position_summary in self.position_summary_dict.values():
            if position_summary.is_clone_mutated_from_ancestor_position(
                    self.print_debug):
                self.clone_mutated_from_ancestor = True  # default False

    def determine_if_gene_segregates(self):
        """Check segregation percentage at each position and find max."""
        gene_max_seg_percent = 0.0
        for position_summary in self.position_summary_dict.values():
            position_summary.determine_if_position_segregates(
                self.analysis.read_percent_to_call_segregating)
            gene_max_seg_percent = max(
                position_summary.position_max_segregating_percent,
                gene_max_seg_percent)
            if position_summary.position_segregates:
                self.gene_segregates = True
        self.gene_max_segregating_percent = gene_max_seg_percent

    def generate_data(
            self, include_segregant_data, include_reference_differences):
        """Calls methods to write reads page and DNA and protein sequences."""
        for position_summary in self.position_summary_dict.values():
            position_summary.write_read_alignment_files(
                self.analysis.output_directory,
                self.analysis.clone_ancestor_pool_list)
        if include_segregant_data and not self.gene_segregates:
            return()
        self.generate_dna_sequences(include_segregant_data)
        if self.type == "ORF":
            self.generate_protein_sequences()
            self.compare_protein_sequences()

    def generate_dna_sequences(self, include_segregant_data):
        """Generate DNA sequences based on segregating mutations."""
        self.dna_sequences['ref_sequence'] = self.feature.extract(
            self.genome.chromosome[self.chr_num].record.seq)
        ancestor_mutation_list = []
        ancestor_positions = []  # TODO: Hack for now, fix later
        for clone_name in self.clone_names:
            single_clone_mutation_list = []
            for position_summary in self.position_summary_dict.values():
                (ancestor_mutation, clone_mutation) = \
                    position_summary.return_position_mutations(
                        clone_name, include_segregant_data)
                if clone_mutation:
                    single_clone_mutation_list.append(clone_mutation)
                if ancestor_mutation:
                    if position_summary.position not in ancestor_positions:
                        ancestor_mutation_list.append(ancestor_mutation)
                        ancestor_positions.append(position_summary.position)
            if single_clone_mutation_list:
                self.dna_sequences[clone_name] = \
                    self.generate_mutated_sequence(
                        self.feature, self.chr_num, clone_name,
                        single_clone_mutation_list)
            else:
                self.dna_sequences[clone_name] = \
                    self.dna_sequences['ref_sequence']
        if ancestor_mutation_list:
            self.dna_sequences[self.analysis.ancestor.name] = \
                self.generate_mutated_sequence(
                    self.feature, self.chr_num,
                    self.analysis.ancestor.name, ancestor_mutation_list)
        else:
            self.dna_sequences[self.analysis.ancestor.name] = \
                self.dna_sequences['ref_sequence']

    def generate_protein_sequences(self):
        """Generate protein sequences from DNA sequences."""
        all_sample_names = self.clone_ancestor_names + ['ref_sequence']
        for sample_name in all_sample_names:
            # print("Gen prot seq for %s gene %s\n" % (
            #     sample_name, self.univ_gene_name))
            self.protein_sequences[sample_name] = \
                self.dna_sequences[sample_name].translate(to_stop=True)
            if not self.protein_sequences[sample_name]:
                # Could occur if mutation in first codon. Label 'X' if so.
                self.protein_sequences[sample_name] = 'X'

    def compare_protein_sequences(self):
        """Compare protein sequences to find if nonsynonymous"""
        for sample_name in self.clone_ancestor_names:
            if (str(self.protein_sequences[sample_name]) !=
                    str(self.protein_sequences[self.analysis.ancestor.name])):
                self.is_nonsynonymous = True  # Default is false

    def generate_mutated_sequence(
            self, ref_feature, chr_num, sample_name, mutation_list):
        """Generates a mutated sequence based on list of mismatches."""
        mutated_chr = \
            self.genome.chromosome[chr_num].record.lower().seq.tomutable()
        offset_list = []
        # print("generating sequence for %s\n" % sample_name)

        #first adjust the chromosome sequence only for snp and indels
        for mutation in mutation_list:
            # print("%s from %s to %s at pos %i\n" % (
            #     mutation.snp_or_indel, mutation.ref_base,
            #     mutation.variant_base, mutation.position))
            if mutation.snp_or_indel == 'snp':
                #Check that the correct base has been chosen:
                if (mutated_chr[mutation.position].upper()
                        != mutation.ref_base.upper()):
                    print(
                        "Error: " + ref_feature.qualifiers['SGDID_pt']
                        + ' type ' + mutation.mutation_type
                        + ' position ' + str(mutation.position)
                        + ' base in chromosome ' + str(chr_num)
                        + ', base by position: '
                        + mutated_chr[mutation.position]
                        + ', ref base: ' + mutation.ref_base
                        + ' in sample ' + sample_name)
                mutated_chr[mutation.position] = mutation.variant_base[0]
        for mutation in mutation_list:
            #insert or delete bases & adjust remaining mismatch positions
            #using offset_list ON THE CHROMOSOME ONLY
            if mutation.snp_or_indel == 'indel':
                mutation_position_temp = mutation.position
                insert_or_delete = mutation.variant_base[0]
                bases = mutation.variant_base[1:]
                # print(insert_or_delete, bases)
                if offset_list:
                    for test_pos, num_bases in offset_list:
                        if mutation.position > test_pos:
                            mutation_position_temp += num_bases
                if insert_or_delete == '+':
                    for base in bases[::-1]:
                        if (base == "+" or base == "/" or base == "-"):
                            break
                        # print("inserting %s\n" % base)
                        mutated_chr.insert(mutation_position_temp + 1, base)
                    offset_list.append((mutation.position, len(bases)))
                elif insert_or_delete == '-':
                    for base in bases:
                        mutated_chr.pop(mutation_position_temp + 1)
                    offset_list.append((mutation.position, -len(bases)))
                else:
                    print("ERROR - no +/- for indel")

        #Now change the feature so that the proper sequence is extracted
        #if there were offsets due to indels.
        #Note that nothing else changes the sequence on the mutated chromosome

        #First adjust the total end of the overall feature
        total_num_offset_bases = 0
        if offset_list:  # i.e. if there were indels
            for test_pos, num_bases in offset_list:
                total_num_offset_bases += num_bases
        new_feature_end = int(str(
            ref_feature.location.end)) + total_num_offset_bases
        temp_feature = SeqFeature(
            FeatureLocation(
                int(str(ref_feature.location.start)), new_feature_end),
            strand=ref_feature.strand,
            location_operator=ref_feature.location_operator
        )

        #Now change the sub feature list
        if ref_feature.sub_features:
            for sub_feature in ref_feature.sub_features:
                start = int(str(sub_feature.location.start))
                end = int(str(sub_feature.location.end))
                if offset_list:
                    for test_pos, num_bases in offset_list:
                        if start > test_pos:
                            start += num_bases
                        if end > test_pos:
                            end += num_bases
                temp_feature.sub_features.append(SeqFeature(
                    FeatureLocation(start, end),
                    strand=ref_feature.strand))

        temp_seqrecord = SeqRecord(mutated_chr.toseq())
        return(temp_feature.extract(temp_seqrecord.seq))

    def generate_file_name(
            self, output_directory, subdirectory, dna_or_protein, suffix):
        """Returns file names for gene dna or protein files."""
        if subdirectory:
            directory = os.path.join(output_directory, subdirectory)
        else:
            directory = output_directory
        return(os.path.join(directory,
                            '.'.join([
                                '_'.join([
                                    str(self.sgdid_pt),
                                    str(self.gene_name),
                                    dna_or_protein]),
                                suffix])))

    def write_fasta_file(self, dna_or_protein, output_directory):
        """Write fasta files for DNA and for protein."""
        file_name = self.generate_file_name(output_directory, 'fasta',
                                            dna_or_protein, 'fasta.txt')
        output_file = open(file_name, 'w')
        if self.gene_name:
            name_of_gene = self.gene_name
        else:
            name_of_gene = self.sgdid
        for sample_name in self.dna_sequences:
            if dna_or_protein == 'dna':
                sequence = self.dna_sequences[sample_name]
            elif dna_or_protein == 'protein':
                sequence = self.protein_sequences[sample_name]
            output_file.write(
                '>' + sample_name + '_'
                + name_of_gene + '_'
                + self.type + '\n')
            output_file.write(str(sequence) + '\n')
        output_file.close()

    def clustalw2_align_sequences(self, dna_or_protein, output_directory):
        """Align fasta files and write clustalw2 alignment."""
        input_file_name = self.generate_file_name(
            output_directory, 'fasta', dna_or_protein, 'fasta.txt')
        aln_file_name = self.generate_file_name(
            output_directory, 'alignment', dna_or_protein, 'aln.txt')
        if os.path.isfile(aln_file_name):
            print('OLD', dna_or_protein, self.sgdid_pt, self.gene_name)
        else:
            print('new', dna_or_protein, self.sgdid_pt, self.gene_name)
            cline = ClustalwCommandline(
                self.analysis.clustal_binary,
                infile=input_file_name,
                outfile=aln_file_name,
                seqnos='on')
            stdout, stderr = cline()

    def find_relative_location(self, position):
        """Input chromosomal location, return the location within gene."""
        if self.feature.sub_features:
            # if there are introns
            all_exon_positions = []
            for sub_feature in self.feature.sub_features:
                exon_positions = range(
                    int(str(sub_feature.location.start)),
                    int(str(sub_feature.location.end)))
                all_exon_positions.extend(
                    all_exon_positions + exon_positions)
            all_exon_positions.sort()
        else:
            all_exon_positions = range(
                int(str(self.feature.location.start)),
                int(str(self.feature.location.end)))
        if self.feature.strand == -1:
            all_exon_positions.reverse()
        rel_location = all_exon_positions.index(position)
        if self.type == "promoter":
            rel_location = -(751 - rel_location)
        return(rel_location)

    def write_mutation_info(
            self, output_directory, mutation_template, should_write_protein,
            tabbed_output, mutation_type):
        """Output string with gene data for html display.

        tabbed_output is placeholder for future use.

        """
        mutation_info_list = []
        sorted_positions = [
            (pos, self.position_summary_dict[pos])
            for pos in sorted(self.position_summary_dict.keys())]
            # Sorts in order of chromosome location
        for position, position_summary in sorted_positions:
            relative_position = self.find_relative_location(position) + 1
                #add one to convert from python numbering
            reads_filename = \
                position_summary.generate_relative_reads_filename()
            sample_info_list = position_summary.generate_sample_info_list(
                tabbed_output)
            sample_info_string = ''
            for line in sample_info_list:
                sample_info_string += (
                    '<li class="sample_mismatches">' + line + '</li>\n')
            protein_list_string = ''
            if should_write_protein:
                protein_list = self.generate_mini_protein_alignment(
                    output_directory, relative_position)
                for line in protein_list:
                    protein_list_string += (
                        '<li class="mismatch_protein">' + line + '</li>\n')
                protein_list_string += '</ul>\n'
            mutation_info_list.append(mutation_template.substitute(
                REL_POSITION=relative_position,
                CHR_NUM=self.chr_num,
                POSITION=position + 1,  # python numbering
                READS_LINK=reads_filename,
                SAMPLE_INFO_LIST=sample_info_string,
                PROTEIN_LIST=protein_list_string))

        return('\n'.join(mutation_info_list))

    def generate_mini_protein_alignment(
            self, output_directory, relative_position):
        """Miniature protein alignment included in gene display."""
        aln_file_name = self.generate_file_name(output_directory, 'alignment',
                                                'protein', 'aln.txt')
        if os.path.isfile(aln_file_name):
            alignment = AlignIO.read(aln_file_name, "clustal")
            protein_position = relative_position // 3
            protein_start = max(0, protein_position - 2)
            protein_end = protein_position + 3
            alignment_string = str(
                alignment[:, protein_start:protein_end])
            alignment_string_list = alignment_string.split('\n')[1:]
                #removes header
        else:
            alignment_string_list = []
        return(alignment_string_list)


class PositionSummary(object):
    """Summary of base position info.

    Instance is created by Gene class instance at first occurance
    of a mutation (for any sample) in a particular location.
    The mutations are contained in mismatch_dict and
    keyed by sample name.

    """
    def __init__(self, mutation, genome, gene_instance):
        self.genome = genome
        self.position = mutation.position
        self.chr_num = mutation.chr_num
        self.gene_instance = gene_instance

        self.mutation_dict = {mutation.sample.name: mutation}  # add first mut
        self.reads_per_sample_dict = {}
        self.position_max_segregating_percent = 0.0
        self.position_segregates = False  # default
        self.position_has_forward_mutation = False  # default

    def add_mutation(self, mutation):
        """Adds max of one mutation per sample in position."""
        if mutation.sample.name in self.mutation_dict:
            print(
                "ERROR - 2 mutations in " + mutation.sample.name +
                " chr " + self.chr_num + " pos " + self.position)
        else:
            self.mutation_dict[mutation.sample.name] = mutation

    def determine_if_position_segregates(self, min_percent_to_call_segregant):
        """Find max segregating percentage and compare to setpoint."""
        position_max_seg_percent = 0.0
        for mutation in self.mutation_dict.values():
            mutation.determine_if_mutation_segregates(
                min_percent_to_call_segregant)
            position_max_seg_percent = max(
                position_max_seg_percent,
                mutation.mutation_max_segregating_percent)
            if mutation.mutation_segregates:
                self.position_segregates = True
        self.position_max_segregating_percent = position_max_seg_percent

    def is_clone_mutated_from_ancestor_position(self, print_debug):
        """Return False if clone is mutated from the ancestor at position."""
        for mutation in self.mutation_dict.values():
            if print_debug:
                print("checking mutation for sample " + mutation.sample.name)
                print("mutation type is " + mutation.mutation_type)
            if (mutation.mutation_type == 'forward mutation' or
                    mutation.mutation_type == 'backmutation'):
                self.position_has_forward_mutation = True
                if print_debug:
                    print("differs from ancestor!")
                return(True)
        if print_debug:
            print("same as ancestor")
        return(False)

    def find_min_reads(self):
        """Return minimum number of reads for all samples at position."""
        self.min_num_reads = min(self.reads_per_sample_dict.values())

    def write_read_alignment_files(self, output_directory, sample_list):
        """Write all reads for a position to an html file.

        TODO: Better align indels using CIGAR format and filter for
        read quality and mapping quality. Can occasionally misalign
        for multiple mutations in same read. CIGAR should fix this.

        """
        relative_filename = self.generate_relative_reads_filename()
        full_filename = os.path.join(output_directory, relative_filename)
        bam_chr_num = self.genome.chr_num_to_chromID_lookup_dict[
            self.chr_num]
        reads_dict = {}
        start_positions = []
        end_positions = []
        for sample in sample_list:
            reads_for_one_sample = ReadsForOneSample(
                self.chr_num, self.position, sample.name)
            bamfile = pysam.Samfile(sample.bam_filename, "rb")
            bamfile.fetch(
                bam_chr_num, self.position, self.position + 1,
                callback=reads_for_one_sample.add_read)
            self.reads_per_sample_dict[sample.name] = len(
                reads_for_one_sample.reads)
            if reads_for_one_sample.reads:
                #Sometimes there are no reads. TODO: deal with this better
                min_position, max_position = \
                    reads_for_one_sample.find_min_max_positions()
                start_positions.append(min_position)
                end_positions.append(max_position)
                reads_dict[sample.name] = reads_for_one_sample
        self.find_min_reads()
        if reads_dict:
            #if statement probably not necessary, but just in case
            start_position = min(start_positions)
            end_position = max(end_positions)
            ref_seq = str(self.genome.chromosome[
                self.chr_num].record.seq[start_position:end_position])
            string_list = []
            for sample_name, reads_for_one_sample \
                    in reads_dict.iteritems():
                string_list.extend(
                    reads_for_one_sample.generate_reads_string(
                        sample_name, start_position, ref_seq, self.position))
            reads_string = '\n'.join(string_list)
            non_python_position = str(self.position + 1)
            file_handle = open(TEMPLATES['reads'], 'r')
            read_template = Template(file_handle.read())
            file_handle.close()
            read_file = open(full_filename, 'w')
            read_file.write(read_template.substitute(
                READS=reads_string, CHROMOSOME_NUMBER=self.chr_num,
                CSS_FILE=CSS_FILE, BASE_CSS_CILE=BASE_CSS_FILE,
                POSITION=non_python_position
            ))
            read_file.close()

    def generate_relative_reads_filename(self):
        """Return full path for reads html file."""
        return(os.path.join('reads', ('align_chr' + str(self.chr_num)
                            + '_pos' + str(self.position + 1) + '.html')))

    def return_position_mutations(self, sample_name, include_segregant_data):
        """Return mutation so be used when generating mutated sequence.

        This is where the filtering occurs to decide if a mismatch
        gets included in the newly genertated mutant sequence.

        """
        if sample_name not in self.mutation_dict:
            return(None, None)  # sample or ancestor don't have a mutation
        if (self.mutation_dict[sample_name].mutation_type ==
                'shares ancestor mutation'):
            return(
                self.mutation_dict[sample_name],
                self.mutation_dict[sample_name])  # don't need to check segreg
        if (include_segregant_data and
                not self.mutation_dict[sample_name].mutation_segregates):
            return(None, None)  # mutation doesn't segregate
        if (self.mutation_dict[sample_name].mutation_type ==
                'backmutation'):
            return(self.mutation_dict[sample_name], None)
        if (self.mutation_dict[sample_name].mutation_type ==
                'forward mutation'):
            return(None, self.mutation_dict[sample_name])
        else:
            print("error in mutant sequence generation")

    def generate_sample_info_list(self, tabbed_output):
        """Generates string for each sample's mutation"""
        sample_info_list = []
        mut_template = \
            '%(smp)s : %(mut)s %(snp)s from %(anc)s to %(chi)s at %(freq)d percent of %(tot)d reads.'
        seg_template = \
            '    %(segsmp)s segregates %(segb)s at %(perc)d percent of %(tot)d reads.'
        for (sample_name, mutation) in self.mutation_dict.iteritems():
            mut_inserts = {
                'mut': mutation.mutation_type,
                'smp': sample_name,
                'snp': mutation.snp_or_indel,
                'anc': mutation.ref_base,
                'chi': mutation.variant_base,
                'freq': mutation.percent_variant_reads_clone,
                'tot': mutation.reads_total_clone}
            sample_info_list.append(mut_template % mut_inserts)
            for segregant in mutation.segregation_info_list:
                seg_inserts = {
                    'segsmp': segregant.pool_name,
                    'segb': segregant.seg_base,
                    'perc': segregant.seg_percent,
                    'tot': segregant.tot_reads}
                sample_info_list.append(seg_template % seg_inserts)
            tabbed_output.write(
                "%s\t%s\t%s\t%i\t%s\t%s\t%s\t%s\t%i\t%i\n" % (
                    self.gene_instance.univ_gene_name,
                    self.gene_instance.sgdid,
                    str(self.chr_num),
                    self.position,
                    sample_name,
                    mutation.snp_or_indel,
                    mutation.ref_base,
                    mutation.variant_base,
                    mutation.percent_variant_reads_clone,
                    mutation.reads_total_clone))
#                'gene_name\tsgdid\tchr_num\tposition\tsample_name\tsnp_indel\tref\tread\tfraction\ttot_reads\n')
        return(sample_info_list)


class ReadsForOneSample(object):

    """Short reads for each sample.

    Serves two functions. First, collects reads as they are read from
    the bam file. Second, generates a string of reads for a single sample
    to be written to the alignment file."""

    def __init__(self, chr_num, position, sample_name):
        self.chr_num = chr_num
        self.position = position
        self.sample_name = sample_name
        self.reads = []

    def add_read(self, alignment):
        """Read added by pysam callback."""
        self.reads.append(alignment)

    def find_min_max_positions(self):
        """Find min and max positions of reads for proper display."""
        start_position_list = [read.pos for read in self.reads]
        end_position_list = [
            (read.pos + len(read.query)) for read in self.reads]
        return(min(start_position_list), max(end_position_list))

    def generate_reads_string(
            self, sample_name, start, ref_seq, mismatch_pos):
        """Generate reads string with |mutation| for easy viewing."""
        self.reads = sorted(self.reads, key=attrgetter('pos'))
        read_template = '{name:22s} {mapq:5s} {readq:4s} {spaces}{seq}'
        reads_string_list = []
        rel_pos = max(mismatch_pos - start, 0)
        mismpos = min(len(ref_seq) - 1, rel_pos)
        ref_seq = (
            ref_seq[:rel_pos] + '|' + ref_seq[mismpos] + '|'
            + ref_seq[mismpos + 1:])
        reads_string_list.append(read_template.format(
            name='Reference', mapq='MapQ', readq='RdQ',
            spaces='', seq=ref_seq))
        for read in self.reads:
            rel_query = mismatch_pos - read.pos
            if rel_query < 0:
                seq = read.query
                read_qual = 'NA'
            if rel_query < len(read.query):
                seq = (
                    read.query[:rel_query] + '|' + read.query[rel_query] + '|'
                    + read.query[(rel_query + 1):])
                read_qual = read.qual[rel_query]
            else:
                seq = read.query
                read_qual = 'NA'
            spaces = ' ' * (read.pos - start)
            reads_string_list.append(read_template.format(
                name=sample_name, mapq=str(read.mapq),
                readq=read_qual, spaces=spaces, seq=seq))
        return(reads_string_list)


class DataOutput(object):
    """One instance of class DataOutput is called to generate all output.

    Generates html output and tabbed file output."""

    def __init__(self, genome, analysis):
        self.genome = genome
        self.analysis = analysis
        self.output_directory = analysis.output_directory
        self.fasta_directory = os.path.join(self.output_directory, 'fasta')
        self.alignment_directory = os.path.join(
            self.output_directory, 'alignment')
        self.reads_directory = os.path.join(self.output_directory, 'reads')
        self.make_directories()
        self.templates = {}
        self.load_html_templates()
        self.sorted_genes = {}

    def make_directories(self):
        """Make output directories if not already made."""
        for directory in [
                self.output_directory, self.fasta_directory,
                self.alignment_directory, self.reads_directory]:
            if not os.path.exists(directory):
                os.makedirs(directory)

    def load_html_templates(self):
        """Load html templates into a dictionary."""
        for template_key, template_filename in TEMPLATES.iteritems():
            file_handle = open(template_filename, 'r')
            self.templates[template_key] = Template(file_handle.read())
            file_handle.close()

    def generate_segregation_output(self):
        """Master method called by segregation pipeline."""
        self.sort_genes_for_output_segregating()
        self.write_supporting_files()
        self.write_mutation_seg_list()
        self.write_segregation_html('anc-clone-seg_pool')

    def generate_multiple_clone_output(self, include_reference_differences):
        """Master method called by multiple clone pipeline."""
        self.sort_genes_for_output_nonsegregating()
        self.write_supporting_files()
        self.write_multiple_clone_output_html(include_reference_differences)

    def sort_genes_for_output_segregating(self):
        """Sort genes into categories in segregation pipeline."""
        self.sorted_genes['nonsynonomous'] = [
            gene for gene in self.analysis.gene_list
            if gene.is_nonsynonymous and gene.gene_segregates]

        self.sorted_genes['synonomous'] = [
            gene for gene in self.analysis.gene_list
            if gene.type == 'ORF' and not gene.is_nonsynonymous
            and gene.gene_segregates]

        self.sorted_genes['promoter'] = [
            gene for gene in self.analysis.gene_list
            if gene.type == 'promoter' and gene.gene_segregates]

        self.sorted_genes['other_mutations'] = [
            gene for gene in self.analysis.gene_list
            if gene.type != 'promoter' and gene.type != 'ORF'
            and gene.gene_segregates]

        self.sorted_genes['nonsegregating'] = [
            gene for gene in self.analysis.gene_list
            if not gene.gene_segregates]

    def sort_genes_for_output_nonsegregating(self):
        """Sort genes into categories in multiple clone pipeline."""
        self.sorted_genes['Clone variant, nonsynonomous'] = [
            gene for gene in self.analysis.gene_list
            if gene.is_nonsynonymous and gene.clone_mutated_from_ancestor]

        self.sorted_genes['Clone variant, synonomous'] = [
            gene for gene in self.analysis.gene_list
            if gene.type == 'ORF' and not gene.is_nonsynonymous
            and gene.clone_mutated_from_ancestor]

        self.sorted_genes['Clone variant, promoter'] = [
            gene for gene in self.analysis.gene_list
            if gene.type == 'promoter' and gene.clone_mutated_from_ancestor]

        self.sorted_genes['Clone variant, other_mutations'] = [
            gene for gene in self.analysis.gene_list
            if gene.type != 'promoter' and gene.type != 'ORF'
            and gene.clone_mutated_from_ancestor]

        self.sorted_genes['Reference variant, nonsynonomous'] = [
            gene for gene in self.analysis.gene_list
            if gene.is_nonsynonymous
            and not gene.clone_mutated_from_ancestor]

        self.sorted_genes['Reference variant, synonomous'] = [
            gene for gene in self.analysis.gene_list
            if gene.type == 'ORF' and not gene.is_nonsynonymous
            and not gene.clone_mutated_from_ancestor]

        self.sorted_genes['Reference variant, promoter'] = [
            gene for gene in self.analysis.gene_list
            if gene.type == 'promoter'
            and not gene.clone_mutated_from_ancestor]

        self.sorted_genes['Reference variant, other_mutations'] = [
            gene for gene in self.analysis.gene_list
            if gene.type != 'promoter' and gene.type != 'ORF'
            and not gene.clone_mutated_from_ancestor]

    def write_supporting_files(self):
        """Master method for calling fasta and alignment writing methods."""
        for gene in self.analysis.gene_list:
            if self.analysis.include_seg_data and not gene.gene_segregates:
                continue
            if gene.is_nonsynonymous:
                should_write_protein_info = True
            else:
                should_write_protein_info = False
            self.write_fasta_file(gene, should_write_protein_info)
            self.write_alignment(gene, should_write_protein_info)

    def write_fasta_file(self, gene, write_protein):
        """Write DNA and, if necessary, protein fasta files to output."""
        gene.write_fasta_file('dna', self.output_directory)
        if write_protein:
            gene.write_fasta_file('protein', self.output_directory)

    def write_alignment(self, gene, write_protein):
        """Write DNA and, if necessary, protein alignment files to output."""
        gene.clustalw2_align_sequences(
            'dna', self.output_directory)
        if write_protein:
            gene.clustalw2_align_sequences(
                'protein', self.output_directory)

    def write_multiple_clone_output_html(self, include_reference_differences):
        """Generate html output for multiple clone pipeline."""
        tabbed_output = open(os.path.join(
            self.output_directory, TABBED_OUTPUT), 'w')
        tabbed_output.write(
            'gene_name\tsgdid\tchr_num\tposition\tsample_name\tsnp_indel\tref\tread\tfraction\ttot_reads\n')

        body_string = ''
        body_string += self.write_strain_list(self.templates['strain'])

        body_string += (
            '<h2 id="clone_variant_nonsynonymous">Nonsynonymous, variant among strains:</h2>\n')
        for gene in self.sorted_genes['Clone variant, nonsynonomous']:
            body_string += self.write_gene(
                gene, True, self.templates['gene'], self.templates['mutation'],
                tabbed_output, 'Clone variant, nonsynonomous')
        body_string += (
            '<h2 id="clone_variant_synonymous">Synonymous, variant among strains:</h2>\n')
        for gene in self.sorted_genes['Clone variant, synonomous']:
            body_string += self.write_gene(
                gene, False, self.templates['gene'],
                self.templates['mutation'],
                tabbed_output, 'Clone variant, synonomous')

        body_string += (
            '<h2 id="clone_variant_promoter">Promoter, variant among strains:</h2>\n')
        for gene in self.sorted_genes['Clone variant, promoter']:
            body_string += self.write_gene(
                gene, False, self.templates['gene'],
                self.templates['mutation'],
                tabbed_output, 'Clone variant, promoter')

        body_string += (
            '<h2 id="clone_variant_other">Other mutation, variant among strains:</h2>\n')
        for gene in self.sorted_genes['Clone variant, other_mutations']:
            body_string += self.write_gene(
                gene, False, self.templates['gene'],
                self.templates['mutation'],
                tabbed_output, 'Clone variant, other')

        if include_reference_differences:
            body_string += (
                '<h2 id="reference_variant_nonsynonymous">Nonsynonymous, reference variant only:</h2>\n')
            for gene in self.sorted_genes['Reference variant, nonsynonomous']:
                body_string += self.write_gene(
                    gene, True, self.templates['gene'],
                    self.templates['mutation'],
                    tabbed_output, 'Reference variant, nonsynonomous')
            body_string += (
                '<h2 id="reference_variant_synonymous">Synonymous, reference variant only:</h2>\n')
            for gene in self.sorted_genes['Reference variant, synonomous']:
                body_string += self.write_gene(
                    gene, False, self.templates['gene'],
                    self.templates['mutation'],
                    tabbed_output, 'Reference variant, synonomous')

            body_string += (
                '<h2 id="reference_variant_promoter">Promoter, reference variant only:</h2>\n')
            for gene in self.sorted_genes['Reference variant, synonomous']:
                body_string += self.write_gene(
                    gene, False, self.templates['gene'],
                    self.templates['mutation'],
                    tabbed_output, 'Reference variant, promoter')

            body_string += (
                '<h2 id="reference_variant_other">Other mutation, reference variant only:</h2>\n')
            for gene in self.sorted_genes['Reference variant, other_mutations']:
                body_string += self.write_gene(
                    gene, False, self.templates['gene'],
                    self.templates['mutation'],
                    tabbed_output, 'Reference variant, other')

        navigation_string = """<li id="t_strains"><a href="#strains">Strains</a></li>
            <li id="t_clone_variant_nonsynonymous"><a href="#clone_variant_nonsynonymous">Nonsynonymous, variant among strains</a></li>
            <li id="t_clone_variant_synonymous"><a href="#clone_variant_synonymous">Synonymous, variant among strains</a></li>
            <li id="t_clone_variant_promoter"><a href="#clone_variant_promoter">Promoter, variant among strains</a></li>
            <li id="t_clone_variant_other"><a href="#clone_variant_other">Clone variant, other_mutations</a></li>
            <li id="t_reference_variant_nonsynonymous"><a href="#reference_variant_nonsynonymous">Nonsynonymous, reference variant only</a></li>
            <li id="t_reference_variant_synonymous"><a href="#reference_variant_synonymous">Synonymous, reference variant only</a></li>
            <li id="t_reference_variant_promoter"><a href="#reference_variant_promoter">Promoter, reference variant only</a></li>
            <li id="t_reference_variant_other"><a href="#reference_variant_other">Clone variant, reference variant only</a></li>
            """

        output_file_name = os.path.join(
            self.output_directory, 'compare.html')
        output_file = open(output_file_name, 'w')
        output_file.write(self.templates['main'].substitute(
            NAVIGATION=navigation_string, BODY=body_string,
            SEQUENCES_TITLE=self.analysis.title,
            CSS_FILE=CSS_FILE, BASE_CSS_FILE=BASE_CSS_FILE
        ))
        output_file.close()
        tabbed_output.close()

        #Copy CSS file
        shutil.copy(CSS_FILE, self.output_directory)
        shutil.copy(BASE_CSS_FILE, self.output_directory)
        shutil.copy(CSS_FILE, os.path.join(
            self.output_directory, 'reads'))
        shutil.copy(BASE_CSS_FILE, os.path.join(
            self.output_directory, 'reads'))

    def write_mutation_seg_list(self):
        """Write tabbed output listing mutations and segregating fraction."""
        mutation_output = open(os.path.join(
            self.output_directory, MUTATION_OUTPUT), 'w')
        mutation_output.write(
            'chr_num\tposition\tsnp_indel\tseg_percent\tgenes\n')
        for mutation_list in self.analysis.mutation_dict.values():
            for mutation in mutation_list:
                output_line = \
                    mutation.generate_output_for_mutation_tabbed_output()
                if output_line:
                    mutation_output.write(output_line)
        mutation_output.close()

    def write_segregation_html(self, format):
        """Writes main html file for segregation pipeline."""
        tabbed_output = open(os.path.join(
            self.output_directory, TABBED_OUTPUT), 'w')
        tabbed_output.write(
            'gene_name\tsgdid\tchr_num\tposition\tsample_name\tsnp_indel\tref\tread\tfraction\ttot_reads\n')

        body_string = ''
        body_string += self.write_strain_list(self.templates['strain'])

        body_string += (
            '<h2 id="nonsynonymous">Nonsynonymous ORF segregating mutations:</h2>\n')
        for gene in self.sorted_genes['nonsynonomous']:
            body_string += self.write_gene(
                gene, True, self.templates['gene'],
                self.templates['mutation'], tabbed_output, 'nonsynonomous')

        body_string += (
            '<h2 id="synonymous">Synonymous ORF segregating mutations:</h2>\n')
        for gene in self.sorted_genes['synonomous']:
            body_string += self.write_gene(
                gene, False, self.templates['gene'],
                self.templates['mutation'], tabbed_output, 'synonomous')

        body_string += ('<h2 id="promoter">Promoter segregating mutations:</h2>\n')
        for gene in self.sorted_genes['promoter']:
            body_string += self.write_gene(
                gene, False, self.templates['gene'],
                self.templates['mutation'], tabbed_output, 'promoter')

        body_string += ('<h2 id="other">Other segregating mutations:</h2>\n')
        for gene in self.sorted_genes['other_mutations']:
            body_string += self.write_gene(
                gene, False, self.templates['gene'],
                self.templates['mutation'], tabbed_output, 'other_mutations')

        body_string += ('<h2 id="nonsegregating">Non-segregating mutations:</h2>\n')
        for gene in self.sorted_genes['nonsegregating']:
            body_string += self.write_gene(
                gene, False, self.templates['gene'],
                self.templates['mutation'], tabbed_output, 'nonsegregating')

        navigation_string = """
            <li id="t_strains"><a href="#strains">Strains</a></li>
            <li id="t_nonsynonymous"><a href="#nonsynonymous">Non-synonymous ORF mutations</a></li>
            <li id="t_synonymous"><a href="#synonymous">Synonymous ORF mutations</a></li>
            <li id="t_promoter"><a href="#promoter">Promoter mutations</a></li>
            <li id="t_other"><a href="#other">Other segregating mutations</a></li>
            <li id="t_nonsegregating"><a href="#nonsegregating">Non-segregating mutations</a></li>
            """

        output_file_name = os.path.join(
            self.output_directory, 'compare.html')
        output_file = open(output_file_name, 'w')
        output_file.write(self.templates['main'].substitute(
            NAVIGATION=navigation_string, BODY=body_string,
            SEQUENCES_TITLE=self.analysis.title,
            CSS_FILE=CSS_FILE, BASE_CSS_FILE=BASE_CSS_FILE
        ))
        output_file.close()
        tabbed_output.close()

        #Copy CSS file
        shutil.copy(CSS_FILE, self.output_directory)
        shutil.copy(CSS_FILE, os.path.join(
            self.output_directory, 'reads'))
        shutil.copy(BASE_CSS_FILE, self.output_directory)
        shutil.copy(BASE_CSS_FILE, os.path.join(
            self.output_directory, 'reads'))

    def write_strain_list(self, header_template):
        """Output string header for html output.

        TODO: Automatically retrieve commented-out info from
        BAM header.

        """
        strain_string = ''
        for sample in self.analysis.clone_ancestor_pool_list:
            strain_string += header_template.substitute(
                STRAIN_NAME=sample.name,
                STRAIN_TYPE=sample.__class__.__name__,
                CHILD_OF=sample.return_parent_name(),
#                    DESCRIPTION = sample_info.description,
#                    DATE_SEQUENCED=sample_info.date_sequenced,
#                    SEQUENCER= sample_info.sequencer,
#                    SEQUENCE_METHOD=sample_info.sequence_method,
#                    ALIGNER= sample_info.aligner,
#                    MISMATCH_CALLER = sample_info.mismatch_caller,
#                    MIN_READS_FOR_MISMATCH =
#                        self.input_parameters.min_reads_to_call_gene_mutated,
#                    READ_PERCENTAGE= sample_info.min_read_percentage,
            )
        return(strain_string)

    def write_gene(
            self, gene, write_protein, gene_template,
            mutation_template, tabbed_output, gene_mutation_type):
        """Generate html string for each gene."""
        name_of_gene = gene.gene_name if gene.gene_name else gene.feature_name

        dna_fasta_file = gene.generate_file_name(
            '', 'fasta', 'dna', 'fasta.txt')
        dna_alignment_file = gene.generate_file_name(
            '', 'alignment', 'dna', 'aln.txt')
        if write_protein:
            protein_or_dna = "Protein mutation"
            protein_fasta_file = gene.generate_file_name(
                '', 'fasta', 'protein', 'fasta.txt')
            protein_fasta = (
                '<p class="protein_links"><a class="file_link" href="' +
                protein_fasta_file + '">Protein fasta</a></p>')
            protein_alignment_file = gene.generate_file_name(
                '', 'alignment', 'protein', 'aln.txt')
            protein_alignment = (
                '<p class="protein_links"><a class="file_link" href="' +
                protein_alignment_file +
                '">Protein alignment</a></p>')
        else:
            protein_or_dna = "DNA mutation"
            protein_fasta = ''
            protein_alignment = ''
        mutation_info = gene.write_mutation_info(
            self.output_directory, mutation_template, write_protein,
            tabbed_output, gene_mutation_type)
        gene_string = gene_template.substitute(
            GENE_NAME=name_of_gene,
            GENE_TYPE=gene.type,
            SGDID=gene.sgdid,
            PROTEIN_OR_DNA=protein_or_dna,
            DNA_FASTA_FILE=dna_fasta_file,
            DNA_ALIGNMENT_FILE=dna_alignment_file,
            PROTEIN_FASTA_FILE=protein_fasta,
            PROTEIN_ALIGNMENT_FILE=protein_alignment,
            MUTATION_INFO=mutation_info,
            FEATURE_NAME=gene.feature_name,
        )
        return(gene_string)


def main(argv=None):
    parser = argparse.ArgumentParser(description = \
            "Classify variants in sequences and rank by segregation frequency")
    parser.add_argument('--title', default=datetime.datetime.now().isoformat(),
            help="Title of analysis")
    parser.add_argument('--output_dir', required=True,
            help="Output directory")
    parser.add_argument('--ref_seq', required=True,
            help="fasta reference sequence")
    parser.add_argument('--ref_feat', required=True,
            help="Reference features tab file")
    parser.add_argument('--ref_chrom_num', 
            help="Tab-file of chrom_name to be used and chrom_id in ref fasta")
    parser.add_argument('--ancestor_bam', required=True,
            help="Ancestor sorted bam file")
    parser.add_argument('--ancestor_name', default = "Ancestor",
            help="Name of ancestor")
    parser.add_argument('--clone_bam', required=True,
            help="Clone sorted bam file")
    parser.add_argument('--clone_snp', required=True,
            help="List of ancestor to clone snps generated by Varscan")
    parser.add_argument('--clone_indel', required=True,
            help="List of ancestor to clone indels generated by Varscan")
    parser.add_argument('--clone_name', default = "Clone",
            help="Name of first clone")
    parser.add_argument('--add_clone_bam', action='append',
            help="Additional clone: Sorted bam file")
    parser.add_argument('--add_clone_name', action='append',
            help="Additional clone: Name")
    parser.add_argument('--add_clone_snp', action='append',
            help="Additional clone: snp file")
    parser.add_argument('--add_clone_indel', action='append',
            help="Additional clone: indel file")
    parser.add_argument('--pool_bam',
            help="Pool sorted bam file. Required for segregation analysis.")
    parser.add_argument('--pool_name', default = "pool",
            help="Name of pool")
    parser.add_argument('--pool_snp',
            help="Pool snp file. Required for segregation analysis.")
    parser.add_argument('--pool_indel',
            help="Pool indel file. Required for segregation analysis.")
    parser.add_argument('--mut_percent', default=60, type=int,
            help="Percentage to call mutant from ancestor to clone")
    parser.add_argument('--seg_percent', default=90, type=int,
            help="Percentage to call segregant")
    all_args = parser.parse_args()

    if (all_args.pool_bam and all_args.pool_snp and all_args.pool_indel):
        if not (all_args.add_clone_bam or all_args.add_clone_snp or all_args.add_clone_indel):
            print("Segregation analysis")
            segregant_analysis_with_clone(
                    all_args.title, all_args.ancestor_name,
                    all_args.ancestor_bam,
                    all_args.ref_seq, all_args.ref_chrom_num,
                    all_args.ref_feat, all_args.output_dir,
                    all_args.clone_name, all_args.clone_bam,
                    all_args.clone_snp, all_args.clone_indel,
                    all_args.mut_percent, 
                    all_args.pool_name, all_args.pool_bam,
                    all_args.pool_snp, all_args.pool_indel,
                    all_args.seg_percent)
        else:
            print("Multiple clones cannot be used with a segregant pool.")
    else:
        pass
        # TODO: multiple clone analysis

if __name__ == "__main__":
    main()
